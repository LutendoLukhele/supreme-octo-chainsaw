"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionLauncherService = void 0;
const events_1 = require("events");
const uuid_1 = require("uuid");
const winston_1 = __importDefault(require("winston"));
const lodash_1 = require("lodash");
const logger = winston_1.default.createLogger({
    level: 'info',
    format: winston_1.default.format.combine(winston_1.default.format.timestamp(), winston_1.default.format.json()),
    transports: [new winston_1.default.transports.Console()],
});
class ActionLauncherService extends events_1.EventEmitter {
    conversationService;
    toolConfigManager;
    beatEngine;
    scratchPadService;
    activeActions = new Map();
    constructor(conversationService, toolConfigManager, beatEngine, scratchPadService) {
        super();
        this.conversationService = conversationService;
        this.toolConfigManager = toolConfigManager;
        this.beatEngine = beatEngine;
        this.scratchPadService = scratchPadService;
        logger.info("ActionLauncherService initialized.");
    }
    /**
     * Resolves placeholder strings in an argument object (e.g., {{step_1.result.id}})
     * with actual data from a completed step in the current run.
     * @param args The arguments object to resolve.
     * @param run The active Run object containing results from previous steps.
     * @returns A new arguments object with placeholders replaced by real data.
     */
    _resolvePlaceholders(args, run) {
        const resolvedArgs = JSON.parse(JSON.stringify(args)); // Deep copy
        const placeholderRegex = /\{\{([^}]+)\}\}/g;
        for (const key in resolvedArgs) {
            const value = resolvedArgs[key];
            if (typeof value === 'string' && placeholderRegex.test(value)) {
                const newStr = value.replace(placeholderRegex, (match, placeholder) => {
                    const [actionId, ...pathParts] = placeholder.split('.');
                    if (!actionId || pathParts.length === 0)
                        return match;
                    const path = pathParts.join('.');
                    const toolExecution = run.tools.find(t => t.toolCall.id === actionId);
                    const toolResult = toolExecution?.result;
                    if (toolResult === undefined) {
                        logger.warn(`Could not resolve placeholder: Action ID '${actionId}' not found or has no result yet.`, { placeholder });
                        return match;
                    }
                    const resolvedValue = (0, lodash_1.get)(toolResult, path);
                    return resolvedValue !== undefined ? JSON.stringify(resolvedValue) : match;
                });
                try {
                    resolvedArgs[key] = JSON.parse(newStr);
                }
                catch (e) {
                    resolvedArgs[key] = newStr.replace(/^"|"$/g, '');
                }
            }
        }
        return resolvedArgs;
    }
    /**
     * Processes a structured plan from the PlannerService. It validates each step,
     * resolves data dependencies, and emits the appropriate messages to the client
     * for either parameter collection or action confirmation.
     * @param actionPlan The plan generated by the PlannerService.
     * @param sessionId The current user session ID.
     * @param userId The current user ID.
     * @param messageId The ID of the message that initiated the plan.
     * @param activeRun The active Run object containing state from previous steps.
     */
    async processActionPlan(actionPlan, sessionId, userId, messageId, activeRun) {
        logger.info(`Processing action plan for session ${sessionId}.`, { numItems: actionPlan.length });
        const clientActionsToConfirm = [];
        const clientActionsNeedingParams = [];
        for (const planItem of actionPlan) {
            const toolName = planItem.tool;
            let actualToolArgs = planItem.arguments || {};
            if (activeRun) {
                actualToolArgs = this._resolvePlaceholders(actualToolArgs, activeRun);
            }
            const missingRequired = this.toolConfigManager.findMissingRequiredParams(toolName, actualToolArgs);
            const missingConditional = this.toolConfigManager.findConditionallyMissingParams(toolName, actualToolArgs);
            const serverSideMissingParams = [...new Set([...missingRequired, ...missingConditional])];
            const serverDeterminedStatus = serverSideMissingParams.length > 0 ? 'collecting_parameters' : 'ready';
            const newActiveAction = this._createAndStoreAction({
                sessionId, messageId,
                actionId: planItem.id || (0, uuid_1.v4)(),
                toolName: toolName,
                description: planItem.intent,
                llmToolCallId: planItem.id,
                args: actualToolArgs,
                missingParameters: serverSideMissingParams,
                initialStatus: serverDeterminedStatus,
            });
            if (serverDeterminedStatus === 'collecting_parameters') {
                clientActionsNeedingParams.push(newActiveAction);
            }
            else if (serverDeterminedStatus === 'ready') {
                clientActionsToConfirm.push(newActiveAction);
            }
        }
        if (clientActionsNeedingParams.length > 0) {
            const analysisText = `I need a bit more information for the '${clientActionsNeedingParams[0].toolDisplayName}' action.`;
            this.emit('send_chunk', sessionId, {
                type: 'parameter_collection_required',
                content: { actions: clientActionsNeedingParams, analysis: analysisText, messageId },
            });
        }
        if (clientActionsToConfirm.length > 0) {
            const analysisText = `The '${clientActionsToConfirm[0].toolDisplayName}' action is ready. Please review and confirm.`;
            this.emit('send_chunk', sessionId, {
                type: 'action_confirmation_required',
                content: { actions: clientActionsToConfirm, analysis: analysisText, messageId },
            });
        }
    }
    /**
     * Executes a single, validated action. This is called by the main server
     * after receiving an 'execute_action' message from the client.
     * @param sessionId The current user session ID.
     * @param userId The current user ID.
     * @param payload The action details from the client.
     * @param toolOrchestrator The service responsible for the final execution.
     * @returns The action object, updated with the result of the execution.
     */
    async executeAction(sessionId, userId, payload, toolOrchestrator) {
        const { actionId } = payload;
        logger.info('Executing action via launcher', { sessionId, actionId });
        const action = this.getAction(sessionId, actionId);
        if (!action)
            throw new Error(`Action ${actionId} not found`);
        if (action.status !== 'ready')
            throw new Error(`Action '${action.toolName}' not ready`);
        const args = {};
        action.parameters.forEach((param) => {
            if (param.currentValue !== undefined) {
                args[param.name] = param.currentValue;
            }
        });
        action.status = 'executing';
        try {
            const toolCall = {
                name: action.toolName,
                arguments: args,
                sessionId: sessionId,
                id: action.id, // Use the action's ID for the toolCall ID to link results
                userId: userId,
                ToolName: '',
                args: {},
                result: []
            };
            const result = await toolOrchestrator.executeTool(toolCall);
            action.result = result.data;
            action.status = result.status === 'success' ? 'completed' : 'failed';
            action.error = result.status === 'failed' ? result.error : undefined;
            if (action.status === 'completed' && result.data) {
                this.scratchPadService.addToolResult(sessionId, action.toolName, args, result.data, toolCall.id);
            }
            return action;
        }
        catch (error) {
            action.status = 'failed';
            action.error = error instanceof Error ? error.message : String(error);
            throw error;
        }
    }
    /**
     * Updates a parameter's value for an active action based on user input from the client.
     * @param sessionId The current user session ID.
     * @param payload The details of the parameter to update.
     * @returns The updated action object or null if not found.
     */
    updateParameterValue(sessionId, payload) {
        const { actionId, paramName, value } = payload;
        logger.info('Updating parameter value', { sessionId, actionId, paramName });
        const action = this.getAction(sessionId, actionId);
        if (!action) {
            logger.warn('Action not found for update', { sessionId, actionId });
            return null;
        }
        const paramIndex = action.parameters.findIndex(p => p.name === paramName);
        if (paramIndex < 0) {
            logger.warn('Parameter not found', { sessionId, actionId, paramName });
            return null;
        }
        action.parameters[paramIndex].currentValue = value;
        const missingIndex = action.missingParameters.indexOf(paramName);
        const isRequired = action.parameters[paramIndex].required;
        const hasValue = value !== null && value !== undefined && String(value).trim() !== '';
        if (isRequired && hasValue && missingIndex >= 0) {
            action.missingParameters.splice(missingIndex, 1);
        }
        else if (isRequired && !hasValue && missingIndex < 0) {
            action.missingParameters.push(paramName);
        }
        const stillMissingRequired = action.missingParameters.length > 0;
        action.status = stillMissingRequired ? 'collecting_parameters' : 'ready';
        // --- FIX: Use the correct 'action' variable ---
        if (!stillMissingRequired && action.status === 'ready') {
            logger.info(`Action ${actionId} is now ready after parameter update. Emitting 'action_ready_for_confirmation'.`, { sessionId, actionId });
            this.emit('action_ready_for_confirmation', { sessionId, actionId, messageId: action.messageId });
        }
        return action;
    }
    /**
     * Retrieves a single active action by its ID.
     * @param sessionId The current user session ID.
     * @param actionId The ID of the action to retrieve.
     * @returns The action object or null if not found.
     */
    getAction(sessionId, actionId) {
        return this.activeActions.get(sessionId)?.get(actionId) || null;
    }
    /**
     * Creates and stores an ActiveAction object in the service's state.
     * @param details The properties of the action to create.
     * @returns The newly created ActiveAction object.
     */
    _createAndStoreAction(details) {
        const toolSchema = this.toolConfigManager.getToolInputSchema(details.toolName);
        let parameterDefinitions = [];
        if (toolSchema?.properties) {
            parameterDefinitions = Object.entries(toolSchema.properties).map(([name, prop]) => ({
                name,
                description: prop.prompt ?? prop.description ?? name,
                required: toolSchema.required?.includes(name) ?? false,
                type: Array.isArray(prop.type) ? prop.type.join('|') : (prop.type || 'string'),
                currentValue: details.args[name],
                hint: prop.hint,
                enumValues: prop.enum,
            }));
        }
        const newActiveAction = {
            id: details.actionId,
            llmToolCallId: details.llmToolCallId,
            messageId: details.messageId,
            action: "execute",
            object: details.toolName,
            toolName: details.toolName,
            toolDisplayName: this.toolConfigManager.getToolDisplayName(details.toolName) || details.toolName.replace(/_/g, ' '),
            description: details.description,
            parameters: parameterDefinitions,
            missingParameters: details.missingParameters,
            status: details.initialStatus,
            result: null,
            error: undefined,
        };
        let sessionActionMap = this.activeActions.get(details.sessionId);
        if (!sessionActionMap) {
            sessionActionMap = new Map();
            this.activeActions.set(details.sessionId, sessionActionMap);
        }
        sessionActionMap.set(details.actionId, newActiveAction);
        return newActiveAction;
    }
}
exports.ActionLauncherService = ActionLauncherService;
